[
{
    "displayText": "Draw()",
    "snippet": "Draw()$1",
    "description": " Draw() is called once per frame after the Update() has completed. This is where all visual updates to your game should take place such as clearing the display, drawing sprites, and pushing raw pixel data into the display. ",
    "type": "method",
    "rightLabel": "Lifecycle"
},
{
    "displayText": "Reset()",
    "snippet": "Reset()$1",
    "description": " Reset() is called when a game is restarted. This is usually called instead of reloading the entire game. It allows you to perform additional configuration that would not be able to happen if the Init() method is not called. This is mostly ignored in the Runner and is mainly used in the Game Creator. ",
    "type": "method",
    "rightLabel": "Lifecycle"
},
{
    "displayText": "Shutdown()",
    "snippet": "Shutdown()$1",
    "description": " Shutdown() is called when quitting a game or shutting down the Runner/Game Creator. This hook allows you to perform any last minute changes to the game's data such as saving or removing any temp files that will not be needed. ",
    "type": "method",
    "rightLabel": "Lifecycle"
},
{
    "displayText": "BackgroundColor(id)",
    "snippet": "BackgroundColor(${1:id})$2",
    "description": " The background color is used to fill the screen when clearing the display. You can use this method to read or update the background color at any point during the GameChip's draw phase. When calling BackgroundColor(), without an argument, it returns the current background color int. You can pass in an optional int to update the background color by calling BackgroundColor(0) where 0 is any valid ID in the ColorChip. Passing in a value such as -1, or one that is out of range, defaults the background color to magenta (#ff00ff) which is the engine's default transparent color. ",
    "type": "method",
    "rightLabel": "Color"
},
{
    "displayText": "Color(id, value)",
    "snippet": "Color(${1:id}, ${2:value})$3",
    "description": " The Color() method allows you to read and update color values in the ColorChip. This method has two modes which require a color ID to work. By calling the method with just an ID, like Color(0), it returns a hex string for the given color at the supplied color ID. By passing in a new hex string, like Color(0, \"#FFFF00\"), you can change the color with the given ID. While you can use this method to modify color values directly, you should avoid doing this at run time since the DisplayChip must parse and cache the new hex value. If you just want to change a color to an existing value, use the ReplaceColor() method. ",
    "type": "method",
    "rightLabel": "Color"
},
{
    "displayText": "TotalColors(ignoreEmpty)",
    "snippet": "TotalColors(${1:ignoreEmpty})$2",
    "description": " The TotalColors() method simply returns the total number of colors in the ColorChip. By default, it returns only colors that have been set to value other than magenta (#FF00FF) which is the default transparent value used by the engine. By calling TotalColors(false), it returns the total available color slots in the ColorChip. ",
    "type": "method",
    "rightLabel": "Color"
},
{
    "displayText": "ColorsPerSprite()",
    "snippet": "ColorsPerSprite()$1",
    "description": " Pixel Vision 8 sprites have limits around how many colors they can display at once which is called the Colors Per Sprite or CPS. The ColorsPerSprite() method returns this value from the SpriteChip. While this is read-only at run-time, it has other important uses. If you set up your ColorChip in palettes, grouping sets of colors together based on the SpriteChip's CPS value, you can use this to shift a sprite's color offset up or down by a fixed amount when drawing it to the display. Since this value does not change when a game is running, it is best to get a reference to it when the game starts up and store it in a local variable. ",
    "type": "method",
    "rightLabel": "Color"
},
{
    "displayText": "ReplaceColor(index, id)",
    "snippet": "ReplaceColor(${1:index}, ${2:id})$3",
    "description": " The ReplaceColor() method allows you to quickly change a color to an existing color without triggering the DisplayChip to parse and cache a new hex value. Consider this an alternative to the Color() method. It is useful for simulating palette swapping animation on sprites pointed to a fixed group of color IDs. Simply cal the ReplaceColor() method and supply a target color ID position, then the new color ID it should point to. Since you are only changing the color's ID pointer, there is little to no performance penalty during the GameChip's draw phase. ",
    "type": "method",
    "rightLabel": "Color"
},
{
    "displayText": "Clear(x, y, width, height)",
    "snippet": "Clear(${1:x}, ${2:y}, ${3:width}, ${4:height})$5",
    "description": " Clearing the display removed all of the existing pixel data, replacing it with the default background color. The Clear() method allows you specify what region of the display to clear. By simply calling Clear(), with no arguments, it automatically clears the entire display. You can manually define an area of the screen to clear by supplying option x, y, width and height arguments. When clearing a specific area of the display, anything outside of the defined boundaries remains on the next draw phase. This is useful for drawing a HUD but clearing the display below for a scrolling map and sprites. Clear can only be used once during the draw phase. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "Display(visible)",
    "snippet": "Display(${1:visible})$2",
    "description": " The display's size defines the visible area where pixel data exists on the screen. Calculating this is important for knowing how to position sprites on the screen. The Display() method allows you to get the resolution of the display at run time. By default, this will return the visble screen area based on the overscan value set on the display chip. To calculate the exact overscan in pixels, you must subtract the full size from the visible size. Simply supply false as an argument to get the full display dimensions. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawPixels(pixelData, x, y, width, height, drawMode, flipH, flipV, colorOffset)",
    "snippet": "DrawPixels(${1:pixelData}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:drawMode}, ${7:flipH}, ${8:flipV}, ${9:colorOffset})$10",
    "description": " This method allows you to draw raw pixel data directly to the display. Depending on which draw mode you use, the pixel data could be rendered as a sprite or drawn directly onto the tilemap cache. Sprites drawn with this method still count against the total number the display can render but you can draw irregularly shaped sprites by defining a custom width and height. For drawnig into the tilemap cache directly, you can use this to change the way the tilemap looks at run-time without having to modify a sprite's pixel data. It is important to note that when you change a tile's sprite ID or color offset, the tilemap redraws it back to the cache overwriting any pixel data that was previously there. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawPixel(x, y, colorRef, drawMode)",
    "snippet": "DrawPixel(${1:x}, ${2:y}, ${3:colorRef}, ${4:drawMode})$5",
    "description": " This method allows you to draw a single pixel to the Tilemap Cache. It's an expensive operation which leverages DrawPixels(). This should only be used in special occasions when batching pixel data draw request aren't possible. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawSprite(id, x, y, flipH, flipV, drawMode, colorOffset)",
    "snippet": "DrawSprite(${1:id}, ${2:x}, ${3:y}, ${4:flipH}, ${5:flipV}, ${6:drawMode}, ${7:colorOffset})$8",
    "description": " Sprites represent individual collections of pixel data at a fixed size. By default, Pixel Vision 8 sprites are 8 x 8 pixels and have a set limit of visible colors. You can use the DrawSprite() method to render any sprite stored in the Sprite Chip. The display also has a limitation on how many sprites can be on the screen at one time. Each time you call DrawSprite(), the sprite counts against the total amount the display can render. If you attempt to draw more sprites than the display can handle, the call is ignored. One thing to keep in mind when drawing sprites is that their x and y position wraps if they reach the right or bottom border of the screen. You need to change the overscan border to hide sprites offscreen. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawSprites(ids, x, y, width, flipH, flipV, drawMode, colorOffset, onScreen, useScrollPos, bounds)",
    "snippet": "DrawSprites(${1:ids}, ${2:x}, ${3:y}, ${4:width}, ${5:flipH}, ${6:flipV}, ${7:drawMode}, ${8:colorOffset}, ${9:onScreen}, ${10:useScrollPos}, ${11:bounds})$12",
    "description": " The DrawSprites method makes it easier to combine and draw groups of sprites to the display in a grid. This is useful when trying to render 4 sprites together as a larger 16x16 pixel graphic. While there is no limit on the size of the sprite group which can be rendered, it is important to note that each sprite in the array still counts as an individual sprite. Sprites passed into the DrawSprites() method are visible if the display can render it. Under the hood, this method uses DrawSprite but solely manages positioning the sprites out in a grid. Another unique feature of his helper method is that it automatically hides sprites that go offscreen. When used with overscan border, it greatly simplifies drawing larger sprites to the display. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawSpriteBlock(id, x, y, width, height, flipH, flipV, drawMode, colorOffset, onScreen, useScrollPos)",
    "snippet": "DrawSpriteBlock(${1:id}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:flipH}, ${7:flipV}, ${8:drawMode}, ${9:colorOffset}, ${10:onScreen}, ${11:useScrollPos})$12",
    "description": " DrawSpriteBlock() is similar to DrawSprites except you define the first sprite (upper left corner) and the width x height (in sprites) to sample from sprite ram. This will create a larger sprite by using neighbor sprites. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawTile(id, c, r, drawMode, colorOffset)",
    "snippet": "DrawTile(${1:id}, ${2:c}, ${3:r}, ${4:drawMode}, ${5:colorOffset})$6",
    "description": " The DrawTile method makes it easier to update the visuals of a tile on any of the map layers. By default, this will modify a single tile's sprite id and color offset. You can also define the DrawMode to target a specific layer. By default, DrawMode.Tile is used, but this method also accepts DrawMode.TilemapCache and DrawMode.UI to target the UI layer above the tilemap. It's important to note that this method can only draw a tile at a specific column and row. If you need pixel perfect drawing on the TilemapCache or UI layer, use the DrawPixels method. Finally, drawing a tile into the tilemap itself will force that tile to be copied to the Tilemap Cache on the next render pass just like calling the Tile() method. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawTiles(ids, c, r, width, drawMode, colorOffset)",
    "snippet": "DrawTiles(${1:ids}, ${2:c}, ${3:r}, ${4:width}, ${5:drawMode}, ${6:colorOffset})$7",
    "description": " The DrawTiles method makes it easier to update the visuals of multiple tiles at once by leveraging the DrawTile method. Simply pass in an Array of sprite IDs, the column, row and width (in tiles) to make bulk changes to a tilemap layer. You can also define the DrawMode to target a specific layer. By default, DrawMode.Tile is used, but this method also accepts DrawMode.TilemapCache and DrawMode.UI to target the UI layer above the tilemap. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawText(text, x, y, drawMode, font, colorOffset, spacing)",
    "snippet": "DrawText(${1:text}, ${2:x}, ${3:y}, ${4:drawMode}, ${5:font}, ${6:colorOffset}, ${7:spacing})$8",
    "description": " The DrawText() method allows you to render text to the display. By supplying a custom DrawMode, you can render characters as individual sprites (DrawMode.Sprite), tiles (DrawMode.Tile) or drawn directly into the tilemap cache (DrawMode.TilemapCache). When drawing text as sprites, you have more flexibility over position, but each character counts against the displays' maximum sprite count. When rendering text to the tilemap, more characters are shown and also increase performance when rendering large amounts of text. You can also define the color offset, letter spacing which only works for sprite and tilemap cache rendering, and a width in characters if you want the text to wrap. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawTilemap(x, y, columns, rows, offsetX, offsetY, drawMode)",
    "snippet": "DrawTilemap(${1:x}, ${2:y}, ${3:columns}, ${4:rows}, ${5:offsetX}, ${6:offsetY}, ${7:drawMode})$8",
    "description": " By default, the tilemap renders to the display by simply calling DrawTilemap(). This automatically fills the entire display with the visible portion of the tilemap. To have more granular control over how to render the tilemap, you can supply an optional X and Y position to change where it draws on the screen. You can also modify the width (columns) and height (rows) that are displayed too. This is useful if you want to show a HUD or some other kind of image on the screen that is not overridden by the tilemap. To scroll the tilemap, you need to call the ScrollPosition() and supply a new scroll X and Y value. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "DrawRect(x, y, width, height, color, drawMode)",
    "snippet": "DrawRect(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:color}, ${6:drawMode})$7",
    "description": " This method allows you to draw a rectangle with a fill color. By default, this method is used to clear the screen but you can supply a color offset to change the color value and use it to fill a rectangle area with a specific color instead. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "RedrawDisplay()",
    "snippet": "RedrawDisplay()$1",
    "description": " You can use RedrawDisplay to make clearing and drawing the tilemap easier. This is a helper method automatically calls both Clear() and DrawTilemap() for you. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "ScrollPosition(x, y)",
    "snippet": "ScrollPosition(${1:x}, ${2:y})$3",
    "description": " You can scroll the tilemap by calling the ScrollPosition() method and supplying a new scroll X and Y position. By default, calling ScrollPosition() with no arguments returns a vector with the current scroll X and Y values. If you supply an X and Y value, it updates the tilemap's scroll position the next time you call the DrawTilemap() method. ",
    "type": "method",
    "rightLabel": "Display"
},
{
    "displayText": "WriteSaveData(key, value)",
    "snippet": "WriteSaveData(${1:key}, ${2:value})$3",
    "description": " Allows you to save string data to the game file itself. This data persistent even after restarting a game. ",
    "type": "method",
    "rightLabel": "File IO"
},
{
    "displayText": "ReadSaveData(key, defaultValue)",
    "snippet": "ReadSaveData(${1:key}, ${2:defaultValue})$3",
    "description": " Allows you to read saved data by supplying a key. If no matching key exists, \"undefined\" is returned. ",
    "type": "method",
    "rightLabel": "File IO"
},
{
    "displayText": "Key(key, state)",
    "snippet": "Key(${1:key}, ${2:state})$3",
    "description": " While the main form of input in Pixel Vision 8 comes from the controllers, you can test for keyboard input by calling the Key() method. When called, this method returns the current state of a key. The method accepts the Keys enum, or an int, for a specific key. In additon, you need to provide the input state to check for. The InputState enum has two states, Down and Released. By default, Down is automatically used which returns true when the key is being pressed in the current frame. When using Released, the method returns true if the key is currently up but was down in the last frame. ",
    "type": "method",
    "rightLabel": "Input"
},
{
    "displayText": "MouseButton(button, state)",
    "snippet": "MouseButton(${1:button}, ${2:state})$3",
    "description": " Pixel Vision 8 supports mouse input. You can get the current state of the mouse's left (0) and right (1) buttons by calling MouseButton(). In addition to supplying a button ID, you also need to provide the InputState enum. The InputState enum contains options for testing the Down and Released states of the supplied button ID. By default, Down is automatically used which returns true when the key was pressed in the current frame. When using Released, the method returns true if the key is currently up but was down in the last frame. ",
    "type": "method",
    "rightLabel": "Input"
},
{
    "displayText": "Button(button, state, controllerID)",
    "snippet": "Button(${1:button}, ${2:state}, ${3:controllerID})$4",
    "description": " The main form of input for Pixel Vision 8 is the controller's buttons. You can get the current state of any button by calling the Button() method and supplying a button ID, an InputState enum, and the controller ID. When called, the Button() method returns a bool for the requested button and its state. The InputState enum contains options for testing the Down and Released states of the supplied button ID. By default, Down is automatically used which returns true when the key was pressed in the current frame. When using Released, the method returns true if the key is currently up but was down in the last frame. ",
    "type": "method",
    "rightLabel": "Input"
},
{
    "displayText": "MousePosition()",
    "snippet": "MousePosition()$1",
    "description": " The MousePosition() method returns a vector for the current cursor's X and Y position. This value is read-only. The mouse's 0,0 position is in the upper left-hand corner of the display ",
    "type": "method",
    "rightLabel": "Input"
},
{
    "displayText": "InputString()",
    "snippet": "InputString()$1",
    "description": " The InputString() method returns the keyboard input entered this frame. This method is useful for capturing keyboard text input. ",
    "type": "method",
    "rightLabel": "Input"
},
{
    "displayText": "PlaySound(id, channel)",
    "snippet": "PlaySound(${1:id}, ${2:channel})$3",
    "description": " This method plays back a sound on a specific channel. The SoundChip has a limit of active channels so playing a sound effect while another was is playing on the same channel will cancel it out and replace with the new sound. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "Sound(id, data)",
    "snippet": "Sound(${1:id}, ${2:data})$3",
    "description": " This method allows your read and write raw sound data on the SoundChip. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "StopSound(channel)",
    "snippet": "StopSound(${1:channel})$2",
    "description": " Use StopSound() to stop any sound playing on a specific channel. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "PlaySong(loopIDs, loop)",
    "snippet": "PlaySong(${1:loopIDs}, ${2:loop})$3",
    "description": " This helper method allows you to automatically load a set of loops as a complete song and plays them back. You can also define if the tracks should loop when they are done playing. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "PauseSong()",
    "snippet": "PauseSong()$1",
    "description": " Toggles the current playback state of the sequencer. If the song is playing it will pause, if it is paused it will play. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "StopSong()",
    "snippet": "StopSong()$1",
    "description": " Stops the sequencer. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "RewindSong(position, loopID)",
    "snippet": "RewindSong(${1:position}, ${2:loopID})$3",
    "description": " Rewinds the sequencer to the beginning of the currently loaded song. You can define the position in the loop and the loop where playback should begin. Calling this method without any arguments will simply rewind the song to the beginning of the first loop. ",
    "type": "method",
    "rightLabel": "Sound"
},
{
    "displayText": "SpriteSize(width, height)",
    "snippet": "SpriteSize(${1:width}, ${2:height})$3",
    "description": " Returns the size of the sprite as a Vector where X and Y represent the width and height. ",
    "type": "method",
    "rightLabel": "Sprite"
},
{
    "displayText": "Sprite(id, data)",
    "snippet": "Sprite(${1:id}, ${2:data})$3",
    "description": " This allows you to return the pixel data of a sprite or overwrite it with new data. Sprite pixel data is an array of color reference ids. When calling the method with only an id argument, you will get the sprite's pixel data. If you supply data, it will overwrite the sprite. It is important to make sure that any new pixel data should be the same length of the existing sprite's pixel data. This can be calculated by multiplying the sprite's width and height. You can add the transparent area to a sprite's data by using -1. ",
    "type": "method",
    "rightLabel": "Sprite"
},
{
    "displayText": "Sprites(ids, width)",
    "snippet": "Sprites(${1:ids}, ${2:width})$3",
    "description": " This allows you to get the pixel data of multiple sprites. This is a read only method but can be used to copy a collection of sprites into memory and draw them to the display in a single pass. ",
    "type": "method",
    "rightLabel": "Sprite"
},
{
    "displayText": "TotalSprites(ignoreEmpty)",
    "snippet": "TotalSprites(${1:ignoreEmpty})$2",
    "description": " Returns the total number of sprites in the system. You can pass in an optional argument to get a total number of sprites the Sprite Chip can store by passing in false for ignoreEmpty. By default, only sprites with pixel data will be included in the total return. ",
    "type": "method",
    "rightLabel": "Sprite"
},
{
    "displayText": "MaxSpriteCount(total)",
    "snippet": "MaxSpriteCount(${1:total})$2",
    "description": " This method returns the maximum number of sprites the Display Chip can render in a single frame. Use this to better understand the limitations of the hardware your game is running on. This is a read only property at runtime. ",
    "type": "method",
    "rightLabel": "Sprite"
},
{
    "displayText": "Flag(column, row, value)",
    "snippet": "Flag(${1:column}, ${2:row}, ${3:value})$4",
    "description": " This allows you to quickly access just the flag value of a tile. This is useful when trying to the caluclate collision on the tilemap. By default, you can call this method and return the flag value. If you supply a new value, it will be overridden on the tile. Changing a tile's flag value does not force the tile to be redrawn to the tilemap cache. ",
    "type": "method",
    "rightLabel": "Tilemap"
},
{
    "displayText": "Tile(column, row, spriteID, colorOffset, flag)",
    "snippet": "Tile(${1:column}, ${2:row}, ${3:spriteID}, ${4:colorOffset}, ${5:flag})$6",
    "description": " This allows you to get the current sprite id, color offset and flag values associated with a given tile. You can optionally supply your own if you want to change the tile's values. Changing a tile's sprite id or color offset will for the tilemap to redraw it to the cache on the next frame. If you are drawing raw pixel data into the tilemap cache in the same position, it will be overwritten with the new tile's pixel data. ",
    "type": "method",
    "rightLabel": "Tilemap"
},
{
    "displayText": "RebuildTilemap(columns, rows, spriteIDs, colorOffsets, flags)",
    "snippet": "RebuildTilemap(${1:columns}, ${2:rows}, ${3:spriteIDs}, ${4:colorOffsets}, ${5:flags})$6",
    "description": " This forces the map to redraw its cached pixel data. Use this to clear any pixel data added after the map created the pixel data cache. ",
    "type": "method",
    "rightLabel": "Tilemap"
},
{
    "displayText": "TilemapSize(width, height)",
    "snippet": "TilemapSize(${1:width}, ${2:height})$3",
    "description": " This will return a vector representing the size of the tilemap in columns (x) and rows (y). To find the size in pixels, you will need to multiply the returned vectors x and y values by the sprite size's x and y. This method also allows you to resize the tilemap by passing in an optional new width and height. Resizing the tile map is destructive, so any changes will automatically clear the tilemap's sprite ids, color offsets, and flag values. ",
    "type": "method",
    "rightLabel": "Tilemap"
},
{
    "displayText": "UpdateTiles(column, row, columns, ids, colorOffset, flag)",
    "snippet": "UpdateTiles(${1:column}, ${2:row}, ${3:columns}, ${4:ids}, ${5:colorOffset}, ${6:flag})$7",
    "description": " A helper method which allows you to update several tiles at once. Simply define the start column and row position, the width of the area to update in tiles and supply a new int array of sprite IDs. You can also modify the color offset and flag value of the tiles via the optional parameters. This helper method uses calls the Tile() method to update each tile, so any changes to a tile will be automatically redrawn to the tilemap's cache. ",
    "type": "method",
    "rightLabel": "Tilemap"
}
]